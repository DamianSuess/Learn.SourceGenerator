using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Learn.SourceGenerator.Mvvm.Extensions;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;

namespace Learn.SourceGenerator.Mvvm.Models;

/// <summary>
/// A model describing the hierarchy info for a specific type.
/// </summary>
/// <param name="FilenameHint">The filename hint for the current type.</param>
/// <param name="MetadataName">The metadata name for the current type.</param>
/// <param name="Namespace">Gets the namespace for the current type.</param>
/// <param name="Hierarchy">Gets the sequence of type definitions containing the current type.</param>
internal sealed partial record HierarchyInfo(string FilenameHint, string MetadataName, string Namespace, ImmutableArray<TypeInfo> Hierarchy)
{
  /// <summary>
  /// Creates a new <see cref="HierarchyInfo"/> instance from a given <see cref="INamedTypeSymbol"/>.
  /// </summary>
  /// <param name="typeSymbol">The input <see cref="INamedTypeSymbol"/> instance to gather info for.</param>
  /// <returns>A <see cref="HierarchyInfo"/> instance describing <paramref name="typeSymbol"/>.</returns>
  public static HierarchyInfo From(INamedTypeSymbol typeSymbol)
  {
    ImmutableArray<TypeInfo>.Builder hierarchy = ImmutableArray.CreateBuilder<TypeInfo>();

    for (INamedTypeSymbol? parent = typeSymbol;
         parent is not null;
         parent = parent.ContainingType)
    {
      hierarchy.Add(new TypeInfo(
          parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
          parent.TypeKind,
          parent.IsRecord));
    }

    return new(
        typeSymbol.GetFullMetadataNameForFileName(),
        typeSymbol.MetadataName,
        typeSymbol.ContainingNamespace.ToDisplayString(new(typeQualificationStyle: NameAndContainingTypesAndNamespaces)),
        hierarchy.ToImmutable());
  }

  /// <summary>
  /// An <see cref="IEqualityComparer{T}"/> implementation for <see cref="HierarchyInfo"/>.
  /// </summary>
  public sealed class Comparer : Comparer<HierarchyInfo, Comparer>
  {
    /// <inheritdoc/>
    protected override void AddToHashCode(ref HashCode hashCode, HierarchyInfo obj)
    {
      hashCode.Add(obj.FilenameHint);
      hashCode.Add(obj.MetadataName);
      hashCode.Add(obj.Namespace);
      hashCode.AddRange(obj.Hierarchy);
    }

    /// <inheritdoc/>
    protected override bool AreEqual(HierarchyInfo x, HierarchyInfo y)
    {
      return
          x.FilenameHint == y.FilenameHint &&
          x.MetadataName == y.MetadataName &&
          x.Namespace == y.Namespace &&
          x.Hierarchy.SequenceEqual(y.Hierarchy);
    }
  }
}


/// <inheritdoc/>
partial record HierarchyInfo
{
  /// <summary>
  /// Creates a <see cref="CompilationUnitSyntax"/> instance wrapping the given members.
  /// </summary>
  /// <param name="memberDeclarations">The input <see cref="MemberDeclarationSyntax"/> instances to use.</param>
  /// <param name="baseList">The optional <see cref="BaseListSyntax"/> instance to add to generated types.</param>
  /// <returns>A <see cref="CompilationUnitSyntax"/> object wrapping <paramref name="memberDeclarations"/>.</returns>
  public CompilationUnitSyntax GetCompilationUnit(
      ImmutableArray<MemberDeclarationSyntax> memberDeclarations,
      BaseListSyntax? baseList = null)
  {
    // Create the partial type declaration with the given member declarations.
    // This code produces a class declaration as follows:
    //
    // partial <TYPE_KIND> TYPE_NAME>
    // {
    //     <MEMBERS>
    // }
    TypeDeclarationSyntax typeDeclarationSyntax =
        Hierarchy[0].GetSyntax()
        .AddModifiers(Token(SyntaxKind.PartialKeyword))
        .AddMembers(memberDeclarations.ToArray());

    // Add the base list, if present
    if (baseList is not null)
    {
      typeDeclarationSyntax = typeDeclarationSyntax.WithBaseList(baseList);
    }

    // Add all parent types in ascending order, if any
    foreach (TypeInfo parentType in Hierarchy.AsSpan().Slice(1))
    {
      typeDeclarationSyntax =
          parentType.GetSyntax()
          .AddModifiers(Token(SyntaxKind.PartialKeyword))
          .AddMembers(typeDeclarationSyntax);
    }

    // Prepare the leading trivia for the generated compilation unit.
    // This will produce code as follows:
    //
    // <auto-generated/>
    // #pragma warning disable
    // #nullable enable
    SyntaxTriviaList syntaxTriviaList = TriviaList(
        Comment("// <auto-generated/>"),
        Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
        Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));

    if (Namespace is "")
    {
      // If there is no namespace, attach the pragma directly to the declared type,
      // and skip the namespace declaration. This will produce code as follows:
      //
      // <SYNTAX_TRIVIA>
      // <TYPE_HIERARCHY>
      return
          CompilationUnit()
          .AddMembers(typeDeclarationSyntax.WithLeadingTrivia(syntaxTriviaList))
          .NormalizeWhitespace();
    }

    // Create the compilation unit with disabled warnings, target namespace and generated type.
    // This will produce code as follows:
    //
    // <SYNTAX_TRIVIA>
    // namespace <NAMESPACE>
    // {
    //     <TYPE_HIERARCHY>
    // }
    return
        CompilationUnit().AddMembers(
        NamespaceDeclaration(IdentifierName(Namespace))
        .WithLeadingTrivia(syntaxTriviaList)
        .AddMembers(typeDeclarationSyntax))
        .NormalizeWhitespace();
  }
}
